"""Auto-fixer for analyzing errors and generating fixes using AI."""

import os
import json
import shutil
import hashlib
from datetime import datetime
from typing import Optional, Dict, List, Any, Tuple
from dataclasses import dataclass, field
from pathlib import Path
from enum import Enum

from ..config import Config
from ..models import AnthropicClient, GeminiClient, OpenAIClient
from .error_detector import ErrorCategory, DetectedError, ErrorDetector
from .fix_strategies import (
    FixStrategy,
    FixResult,
    FixType,
    FixerCollection,
    DependencyFixer,
    PortFixer,
    ConfigurationFixer,
)


class FixConfidence(Enum):
    """Confidence levels for fixes."""
    HIGH = "high"      # > 0.8
    MEDIUM = "medium"  # 0.5 - 0.8
    LOW = "low"        # < 0.5


@dataclass
class AnalysisResult:
    """Result of error analysis."""
    error: DetectedError
    root_cause: str
    fix_suggestions: List[str]
    affected_files: List[str]
    confidence: float
    requires_ai: bool
    recommended_model: str = "anthropic"  # Default to Claude for coding


@dataclass
class GeneratedFix:
    """A fix generated by AI or strategy."""
    error: DetectedError
    fix_type: FixType
    description: str
    file_changes: Dict[str, str]  # file_path -> new_content
    commands: List[str]  # Commands to run
    confidence: float
    model_used: Optional[str] = None
    reasoning: str = ""
    validation_passed: bool = False


@dataclass
class FixAttempt:
    """Record of a fix attempt."""
    timestamp: datetime
    error: DetectedError
    fix: GeneratedFix
    result: FixResult
    backup_path: Optional[str] = None
    rollback_needed: bool = False


class AutoFixer:
    """Intelligent auto-fixer using AI models to analyze and fix errors."""
    
    def __init__(
        self,
        config: Config,
        backup_dir: Optional[Path] = None,
        max_attempts: int = 5,
        confidence_threshold: float = 0.7,
        enable_backup: bool = True,
        validate_fixes: bool = True,
    ):
        """Initialize the AutoFixer.
        
        Args:
            config: Configuration with API keys
            backup_dir: Directory for backups (default: project/.auto_fixer_backups)
            max_attempts: Maximum fix attempts per error
            confidence_threshold: Minimum confidence to apply fix
            enable_backup: Whether to backup files before changes
            validate_fixes: Whether to validate fixes before applying
        """
        self.config = config
        self.backup_dir = backup_dir
        self.max_attempts = max_attempts
        self.confidence_threshold = confidence_threshold
        self.enable_backup = enable_backup
        self.validate_fixes = validate_fixes
        
        # Initialize AI clients
        self._init_clients()
        
        # Initialize fixers
        self.fixers = FixerCollection()
        self.error_detector = ErrorDetector()
        
        # Track fix history
        self.fix_history: List[FixAttempt] = []
        self.successful_fixes: List[FixAttempt] = []
        self.failed_fixes: List[FixAttempt] = []
    
    def _init_clients(self):
        """Initialize AI clients for different fix types."""
        self.clients = {}
        
        # Claude for coding tasks (primary fixer)
        if self.config.anthropic_api_key:
            self.clients["anthropic"] = AnthropicClient(
                self.config.anthropic_api_key,
                self.config.models.anthropic_model
            )
        
        # GPT for analysis
        if self.config.openai_api_key:
            self.clients["openai"] = OpenAIClient(
                self.config.openai_api_key,
                self.config.models.openai_model
            )
        
        # Gemini for alternative perspectives
        if self.config.gemini_api_key:
            self.clients["gemini"] = GeminiClient(
                self.config.gemini_api_key,
                self.config.models.gemini_model
            )
    
    def analyze_error(
        self,
        error: DetectedError,
        project_path: Path,
        context: Optional[Dict[str, Any]] = None,
    ) -> AnalysisResult:
        """Use AI models to understand the error deeply.
        
        Args:
            error: The detected error to analyze
            project_path: Path to the project root
            context: Additional context (previous errors, project info)
            
        Returns:
            AnalysisResult with root cause and suggestions
        """
        # First, check if this is a simple auto-fixable error
        if self.fixers.can_auto_fix(error):
            return self._analyze_simple_error(error)
        
        # For complex errors, use AI analysis
        return self._analyze_with_ai(error, project_path, context)
    
    def _analyze_simple_error(self, error: DetectedError) -> AnalysisResult:
        """Analyze simple, auto-fixable errors."""
        affected_files = [error.file_path] if error.file_path else []
        
        if error.category == ErrorCategory.DEPENDENCY:
            return AnalysisResult(
                error=error,
                root_cause="Missing dependency",
                fix_suggestions=error.suggested_fixes,
                affected_files=affected_files,
                confidence=0.9,
                requires_ai=False,
            )
        
        if error.category == ErrorCategory.IMPORT:
            module = (
                DependencyFixer.extract_missing_npm_package(error) or
                DependencyFixer.extract_missing_python_module(error) or
                "unknown module"
            )
            return AnalysisResult(
                error=error,
                root_cause=f"Missing module: {module}",
                fix_suggestions=[f"Install {module}"] + error.suggested_fixes,
                affected_files=affected_files,
                confidence=0.85,
                requires_ai=False,
            )
        
        if error.category == ErrorCategory.PORT_IN_USE:
            port = PortFixer.extract_port(error)
            return AnalysisResult(
                error=error,
                root_cause=f"Port {port} is already in use",
                fix_suggestions=[
                    f"Kill process using port {port}",
                    "Use a different port",
                ],
                affected_files=[],
                confidence=0.9,
                requires_ai=False,
            )
        
        if error.category == ErrorCategory.PERMISSION:
            return AnalysisResult(
                error=error,
                root_cause="Insufficient file/directory permissions",
                fix_suggestions=error.suggested_fixes,
                affected_files=affected_files,
                confidence=0.8,
                requires_ai=False,
            )
        
        # Default for other simple errors
        return AnalysisResult(
            error=error,
            root_cause=error.message,
            fix_suggestions=error.suggested_fixes,
            affected_files=affected_files,
            confidence=0.6,
            requires_ai=True,
        )
    
    def _analyze_with_ai(
        self,
        error: DetectedError,
        project_path: Path,
        context: Optional[Dict[str, Any]] = None,
    ) -> AnalysisResult:
        """Analyze error using AI models."""
        # Prefer OpenAI for analysis (GPT is good at understanding)
        client = self.clients.get("openai") or self.clients.get("gemini")
        
        if not client:
            # Fall back to simple analysis
            return self._analyze_simple_error(error)
        
        # Build analysis prompt
        prompt = self._build_analysis_prompt(error, project_path, context)
        
        try:
            response = client.complete_sync(
                prompt,
                system_prompt="You are an expert software debugger. Analyze errors and provide clear, actionable insights."
            )
            
            if response.success:
                return self._parse_analysis_response(error, response.content)
        except Exception as e:
            pass  # Fall back to simple analysis
        
        return self._analyze_simple_error(error)
    
    def _build_analysis_prompt(
        self,
        error: DetectedError,
        project_path: Path,
        context: Optional[Dict[str, Any]] = None,
    ) -> str:
        """Build a prompt for error analysis."""
        # Try to read the problematic file
        file_content = ""
        if error.file_path:
            try:
                file_path = Path(error.file_path)
                if not file_path.is_absolute():
                    file_path = project_path / file_path
                if file_path.exists():
                    content = file_path.read_text()
                    # Get context around the error line
                    if error.line_number:
                        lines = content.split("\n")
                        start = max(0, error.line_number - 10)
                        end = min(len(lines), error.line_number + 10)
                        file_content = "\n".join(
                            f"{i+1}: {line}" for i, line in enumerate(lines[start:end], start)
                        )
                    else:
                        file_content = content[:2000]  # First 2000 chars
            except Exception:
                pass
        
        prompt_parts = [
            "Analyze this error and provide insights:",
            f"\n## Error Category: {error.category.value}",
            f"\n## Error Message:\n{error.message}",
        ]
        
        if error.file_path:
            prompt_parts.append(f"\n## File: {error.file_path}")
        if error.line_number:
            prompt_parts.append(f"## Line: {error.line_number}")
        
        if error.stack_trace:
            prompt_parts.append(f"\n## Stack Trace:\n{error.stack_trace}")
        
        if file_content:
            prompt_parts.append(f"\n## Code Context:\n```\n{file_content}\n```")
        
        if context:
            prompt_parts.append(f"\n## Additional Context:\n{json.dumps(context, indent=2)}")
        
        prompt_parts.append("""
Please provide:
1. ROOT_CAUSE: The fundamental reason for this error
2. AFFECTED_FILES: List of files that likely need changes
3. FIX_SUGGESTIONS: Specific steps to fix this
4. CONFIDENCE: Your confidence level (0.0 to 1.0)
5. REQUIRES_AI: Does fixing this need code generation? (true/false)

Format your response as JSON.""")
        
        return "\n".join(prompt_parts)
    
    def _parse_analysis_response(self, error: DetectedError, response: str) -> AnalysisResult:
        """Parse AI analysis response into AnalysisResult."""
        try:
            # Try to extract JSON from response
            json_match = response
            if "```json" in response:
                json_match = response.split("```json")[1].split("```")[0]
            elif "```" in response:
                json_match = response.split("```")[1].split("```")[0]
            
            data = json.loads(json_match)
            
            return AnalysisResult(
                error=error,
                root_cause=data.get("ROOT_CAUSE", error.message),
                fix_suggestions=data.get("FIX_SUGGESTIONS", error.suggested_fixes),
                affected_files=data.get("AFFECTED_FILES", [error.file_path] if error.file_path else []),
                confidence=float(data.get("CONFIDENCE", 0.5)),
                requires_ai=data.get("REQUIRES_AI", True),
            )
        except (json.JSONDecodeError, KeyError, ValueError):
            # Parse plain text response
            return AnalysisResult(
                error=error,
                root_cause=response[:500] if response else error.message,
                fix_suggestions=error.suggested_fixes,
                affected_files=[error.file_path] if error.file_path else [],
                confidence=0.5,
                requires_ai=True,
            )
    
    def generate_fix(
        self,
        error: DetectedError,
        analysis: AnalysisResult,
        project_path: Path,
    ) -> Optional[GeneratedFix]:
        """Create code fixes using Claude (best for coding).
        
        Args:
            error: The error to fix
            analysis: Analysis result from analyze_error
            project_path: Path to the project root
            
        Returns:
            GeneratedFix if successful, None otherwise
        """
        # For simple errors, use strategy-based fixes
        if not analysis.requires_ai:
            return self._generate_strategy_fix(error, project_path)
        
        # For complex errors, use Claude
        return self._generate_ai_fix(error, analysis, project_path)
    
    def _generate_strategy_fix(
        self,
        error: DetectedError,
        project_path: Path,
    ) -> Optional[GeneratedFix]:
        """Generate fix using predefined strategies."""
        # Dependency fixes
        if error.category in (ErrorCategory.DEPENDENCY, ErrorCategory.IMPORT):
            npm_package = DependencyFixer.extract_missing_npm_package(error)
            if npm_package:
                return GeneratedFix(
                    error=error,
                    fix_type=FixType.DEPENDENCY,
                    description=f"Install npm package: {npm_package}",
                    file_changes={},
                    commands=[f"npm install {npm_package}"],
                    confidence=0.85,
                    reasoning="Missing npm dependency detected",
                )
            
            py_module = DependencyFixer.extract_missing_python_module(error)
            if py_module:
                return GeneratedFix(
                    error=error,
                    fix_type=FixType.DEPENDENCY,
                    description=f"Install Python package: {py_module}",
                    file_changes={},
                    commands=[f"pip install {py_module}"],
                    confidence=0.85,
                    reasoning="Missing Python dependency detected",
                )
        
        # Port fixes
        if error.category == ErrorCategory.PORT_IN_USE:
            port = PortFixer.extract_port(error)
            if port:
                return GeneratedFix(
                    error=error,
                    fix_type=FixType.PORT,
                    description=f"Kill process using port {port}",
                    file_changes={},
                    commands=[f"lsof -ti :{port} | xargs kill -9 2>/dev/null || true"],
                    confidence=0.9,
                    reasoning=f"Port {port} is in use by another process",
                )
        
        # Configuration fixes
        if error.category == ErrorCategory.CONFIGURATION:
            env_file = project_path / ".env"
            example_file = project_path / ".env.example"
            
            if not env_file.exists() and example_file.exists():
                return GeneratedFix(
                    error=error,
                    fix_type=FixType.CONFIGURATION,
                    description="Create .env from .env.example",
                    file_changes={str(env_file): example_file.read_text()},
                    commands=[],
                    confidence=0.9,
                    reasoning="Missing .env file, template available",
                )
        
        return None
    
    def _generate_ai_fix(
        self,
        error: DetectedError,
        analysis: AnalysisResult,
        project_path: Path,
    ) -> Optional[GeneratedFix]:
        """Generate fix using AI (Claude preferred)."""
        # Use Claude for code generation
        client = self.clients.get("anthropic") or self.clients.get("openai")
        
        if not client:
            return None
        
        model_name = "anthropic" if "anthropic" in self.clients else "openai"
        
        # Build fix generation prompt
        prompt = self._build_fix_prompt(error, analysis, project_path)
        
        try:
            response = client.complete_sync(
                prompt,
                system_prompt="""You are an expert software engineer specializing in debugging and fixing code. 
Generate precise, minimal fixes that solve the problem without introducing new issues.
Always explain your reasoning and provide complete file contents when making changes."""
            )
            
            if response.success:
                return self._parse_fix_response(error, response.content, model_name)
        except Exception as e:
            pass
        
        return None
    
    def _build_fix_prompt(
        self,
        error: DetectedError,
        analysis: AnalysisResult,
        project_path: Path,
    ) -> str:
        """Build a prompt for fix generation."""
        # Read affected files
        file_contents = {}
        for file_path in analysis.affected_files:
            try:
                full_path = Path(file_path)
                if not full_path.is_absolute():
                    full_path = project_path / file_path
                if full_path.exists():
                    file_contents[file_path] = full_path.read_text()[:5000]
            except Exception:
                pass
        
        prompt_parts = [
            "Generate a fix for this error:",
            f"\n## Error: {error.message}",
            f"\n## Root Cause: {analysis.root_cause}",
            f"\n## Category: {error.category.value}",
        ]
        
        if error.file_path:
            prompt_parts.append(f"\n## Primary File: {error.file_path}")
        if error.line_number:
            prompt_parts.append(f"## Line Number: {error.line_number}")
        
        if file_contents:
            prompt_parts.append("\n## Current File Contents:")
            for path, content in file_contents.items():
                prompt_parts.append(f"\n### {path}\n```\n{content}\n```")
        
        prompt_parts.append("""
Generate a fix with the following JSON structure:
{
    "description": "Brief description of the fix",
    "reasoning": "Why this fix works",
    "confidence": 0.0 to 1.0,
    "file_changes": {
        "path/to/file.ext": "complete new file content"
    },
    "commands": ["any shell commands needed"]
}

IMPORTANT:
- Provide COMPLETE file contents for any files you modify
- Make minimal changes - don't rewrite more than necessary
- Ensure the fix is syntactically correct
- Commands should be shell-safe""")
        
        return "\n".join(prompt_parts)
    
    def _parse_fix_response(
        self,
        error: DetectedError,
        response: str,
        model_name: str,
    ) -> Optional[GeneratedFix]:
        """Parse AI fix response."""
        try:
            # Extract JSON from response
            json_match = response
            if "```json" in response:
                json_match = response.split("```json")[1].split("```")[0]
            elif "```" in response:
                parts = response.split("```")
                for part in parts:
                    if "{" in part and "}" in part:
                        json_match = part
                        break
            
            data = json.loads(json_match)
            
            return GeneratedFix(
                error=error,
                fix_type=FixType.CODE_MODIFICATION,
                description=data.get("description", "AI-generated fix"),
                file_changes=data.get("file_changes", {}),
                commands=data.get("commands", []),
                confidence=float(data.get("confidence", 0.6)),
                model_used=model_name,
                reasoning=data.get("reasoning", ""),
            )
        except (json.JSONDecodeError, KeyError, ValueError) as e:
            return None
    
    def backup_files(
        self,
        files: List[str],
        project_path: Path,
    ) -> Optional[str]:
        """Create backups before applying fixes.
        
        Args:
            files: List of file paths to backup
            project_path: Project root path
            
        Returns:
            Backup directory path if successful, None otherwise
        """
        if not self.enable_backup:
            return None
        
        # Create backup directory
        backup_dir = self.backup_dir or (project_path / ".auto_fixer_backups")
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_path = backup_dir / timestamp
        
        try:
            backup_path.mkdir(parents=True, exist_ok=True)
            
            for file_path in files:
                full_path = Path(file_path)
                if not full_path.is_absolute():
                    full_path = project_path / file_path
                
                if full_path.exists():
                    # Preserve directory structure in backup
                    relative = full_path.relative_to(project_path) if project_path in full_path.parents or full_path.parent == project_path else full_path.name
                    backup_file = backup_path / relative
                    backup_file.parent.mkdir(parents=True, exist_ok=True)
                    shutil.copy2(full_path, backup_file)
            
            # Create manifest
            manifest = {
                "timestamp": timestamp,
                "files": files,
                "project_path": str(project_path),
            }
            (backup_path / "manifest.json").write_text(json.dumps(manifest, indent=2))
            
            return str(backup_path)
            
        except Exception as e:
            return None
    
    def validate_fix(
        self,
        fix: GeneratedFix,
        project_path: Path,
    ) -> Tuple[bool, str]:
        """Check if the fix is syntactically correct.
        
        Args:
            fix: The generated fix to validate
            project_path: Project root path
            
        Returns:
            Tuple of (is_valid, message)
        """
        if not self.validate_fixes:
            return True, "Validation disabled"
        
        # Validate file changes
        for file_path, content in fix.file_changes.items():
            # Check file extension and validate syntax
            if file_path.endswith(".py"):
                is_valid, msg = self._validate_python(content)
                if not is_valid:
                    return False, f"Python syntax error in {file_path}: {msg}"
            
            elif file_path.endswith(".json"):
                is_valid, msg = self._validate_json(content)
                if not is_valid:
                    return False, f"JSON syntax error in {file_path}: {msg}"
            
            elif file_path.endswith((".js", ".jsx", ".ts", ".tsx")):
                # Basic check for JS/TS (matching brackets)
                is_valid, msg = self._validate_brackets(content)
                if not is_valid:
                    return False, f"Bracket mismatch in {file_path}: {msg}"
        
        # Validate commands (basic safety check)
        for cmd in fix.commands:
            is_valid, msg = self._validate_command(cmd)
            if not is_valid:
                return False, f"Unsafe command: {msg}"
        
        fix.validation_passed = True
        return True, "Validation passed"
    
    def _validate_python(self, content: str) -> Tuple[bool, str]:
        """Validate Python syntax."""
        try:
            compile(content, "<string>", "exec")
            return True, "Valid"
        except SyntaxError as e:
            return False, f"Line {e.lineno}: {e.msg}"
    
    def _validate_json(self, content: str) -> Tuple[bool, str]:
        """Validate JSON syntax."""
        try:
            json.loads(content)
            return True, "Valid"
        except json.JSONDecodeError as e:
            return False, f"Line {e.lineno}: {e.msg}"
    
    def _validate_brackets(self, content: str) -> Tuple[bool, str]:
        """Basic bracket matching validation."""
        stack = []
        pairs = {")": "(", "]": "[", "}": "{"}
        
        in_string = False
        string_char = None
        prev_char = None
        
        for i, char in enumerate(content):
            # Handle strings (skip content inside strings)
            if char in "\"'" and prev_char != "\\":
                if in_string:
                    if char == string_char:
                        in_string = False
                else:
                    in_string = True
                    string_char = char
            
            if not in_string:
                if char in "([{":
                    stack.append((char, i))
                elif char in ")]}":
                    if not stack:
                        return False, f"Unexpected '{char}' at position {i}"
                    if stack[-1][0] != pairs[char]:
                        return False, f"Mismatched bracket at position {i}"
                    stack.pop()
            
            prev_char = char
        
        if stack:
            return False, f"Unclosed '{stack[-1][0]}' at position {stack[-1][1]}"
        
        return True, "Valid"
    
    def _validate_command(self, cmd: str) -> Tuple[bool, str]:
        """Validate command safety."""
        # Block dangerous commands
        dangerous_patterns = [
            r"\brm\s+-rf\s+/",  # rm -rf /
            r"\brm\s+-rf\s+~",  # rm -rf ~
            r">\s*/dev/sd",     # Writing to disk devices
            r"mkfs\.",          # Format filesystem
            r":(){.*:};:",      # Fork bomb
            r"dd\s+if=.*of=/dev", # dd to device
        ]
        
        import re
        for pattern in dangerous_patterns:
            if re.search(pattern, cmd):
                return False, f"Potentially dangerous: matches {pattern}"
        
        return True, "Safe"
    
    def apply_fix(
        self,
        fix: GeneratedFix,
        project_path: Path,
    ) -> FixResult:
        """Safely apply the fix to the codebase.
        
        Args:
            fix: The fix to apply
            project_path: Project root path
            
        Returns:
            FixResult with outcome
        """
        changes_made = []
        rollback_info = {}
        
        # Validate first
        is_valid, validation_msg = self.validate_fix(fix, project_path)
        if not is_valid:
            return FixResult(
                success=False,
                strategy=FixStrategy(
                    name="auto_fix",
                    description=fix.description,
                    fix_type=fix.fix_type,
                    error_categories=[fix.error.category],
                    confidence=fix.confidence,
                ),
                message=f"Validation failed: {validation_msg}",
            )
        
        # Backup files before changes
        files_to_backup = list(fix.file_changes.keys())
        backup_path = self.backup_files(files_to_backup, project_path)
        
        try:
            # Apply file changes
            for file_path, new_content in fix.file_changes.items():
                full_path = Path(file_path)
                if not full_path.is_absolute():
                    full_path = project_path / file_path
                
                # Store original content for rollback
                if full_path.exists():
                    rollback_info[str(full_path)] = full_path.read_text()
                else:
                    rollback_info[str(full_path)] = None  # File was created
                
                # Create parent directories if needed
                full_path.parent.mkdir(parents=True, exist_ok=True)
                
                # Write new content
                full_path.write_text(new_content)
                changes_made.append(f"Modified: {file_path}")
            
            # Run commands
            import subprocess
            for cmd in fix.commands:
                try:
                    result = subprocess.run(
                        cmd,
                        shell=True,
                        cwd=str(project_path),
                        capture_output=True,
                        text=True,
                        timeout=120,
                    )
                    if result.returncode == 0:
                        changes_made.append(f"Executed: {cmd}")
                    else:
                        # Command failed, but we continue
                        changes_made.append(f"Command failed: {cmd} - {result.stderr[:100]}")
                except subprocess.TimeoutExpired:
                    changes_made.append(f"Command timed out: {cmd}")
            
            # Record this fix attempt
            attempt = FixAttempt(
                timestamp=datetime.now(),
                error=fix.error,
                fix=fix,
                result=FixResult(
                    success=True,
                    strategy=FixStrategy(
                        name="auto_fix",
                        description=fix.description,
                        fix_type=fix.fix_type,
                        error_categories=[fix.error.category],
                        confidence=fix.confidence,
                    ),
                    message="Fix applied successfully",
                    changes_made=changes_made,
                    rollback_info=rollback_info,
                ),
                backup_path=backup_path,
            )
            self.fix_history.append(attempt)
            self.successful_fixes.append(attempt)
            
            return attempt.result
            
        except Exception as e:
            # Attempt rollback on failure
            self.rollback_fix(rollback_info, project_path)
            
            return FixResult(
                success=False,
                strategy=FixStrategy(
                    name="auto_fix",
                    description=fix.description,
                    fix_type=fix.fix_type,
                    error_categories=[fix.error.category],
                    confidence=fix.confidence,
                ),
                message=f"Apply failed: {str(e)}",
                rollback_info=rollback_info,
            )
    
    def rollback_fix(
        self,
        rollback_info: Dict[str, Any],
        project_path: Path,
    ) -> bool:
        """Revert if fix makes things worse.
        
        Args:
            rollback_info: Dictionary mapping file paths to original content
            project_path: Project root path
            
        Returns:
            True if rollback successful
        """
        try:
            for file_path, original_content in rollback_info.items():
                full_path = Path(file_path)
                
                if original_content is None:
                    # File was created, delete it
                    if full_path.exists():
                        full_path.unlink()
                else:
                    # Restore original content
                    full_path.write_text(original_content)
            
            return True
        except Exception as e:
            return False
    
    def rollback_from_backup(
        self,
        backup_path: str,
        project_path: Path,
    ) -> bool:
        """Restore files from a backup directory.
        
        Args:
            backup_path: Path to backup directory
            project_path: Project root path
            
        Returns:
            True if restore successful
        """
        try:
            backup_dir = Path(backup_path)
            manifest_file = backup_dir / "manifest.json"
            
            if not manifest_file.exists():
                return False
            
            manifest = json.loads(manifest_file.read_text())
            
            for file_path in manifest.get("files", []):
                relative_path = Path(file_path)
                if relative_path.is_absolute():
                    relative_path = relative_path.relative_to(project_path)
                
                backup_file = backup_dir / relative_path
                restore_path = project_path / relative_path
                
                if backup_file.exists():
                    restore_path.parent.mkdir(parents=True, exist_ok=True)
                    shutil.copy2(backup_file, restore_path)
            
            return True
        except Exception as e:
            return False
    
    def get_fix_summary(self) -> str:
        """Generate a summary of all fix attempts."""
        lines = ["# Auto-Fixer Summary\n"]
        
        lines.append(f"**Total Attempts:** {len(self.fix_history)}")
        lines.append(f"**Successful:** {len(self.successful_fixes)}")
        lines.append(f"**Failed:** {len(self.failed_fixes)}")
        
        if self.successful_fixes:
            lines.append("\n## Successful Fixes\n")
            for attempt in self.successful_fixes:
                lines.append(f"- **{attempt.fix.description}**")
                lines.append(f"  - Error: {attempt.error.message[:100]}")
                lines.append(f"  - Confidence: {attempt.fix.confidence:.2f}")
                if attempt.fix.model_used:
                    lines.append(f"  - Model: {attempt.fix.model_used}")
        
        if self.failed_fixes:
            lines.append("\n## Failed Fixes\n")
            for attempt in self.failed_fixes:
                lines.append(f"- **{attempt.fix.description}**")
                lines.append(f"  - Error: {attempt.result.message}")
        
        return "\n".join(lines)
